#!/bin/bash

# Author:   Andrey Dibrov (andry at inbox dot ru)

# Tacklelib project library bash shell script module
# (https://sf.net/p/tacklelib ).
#
# Base bash shell library module with a basic set of functionality.
# Designed to be included through the absolute path and the source command -
# `source "/bin/bash_entry"`.
# After that all other scripts can be included through the different inclusion
# function - `tkl_include`.
#
# The `tkl_include` function does use an alternative search logic and instead
# of a current directory path a being included shell script is searched through
# the inclusion path variable - `BASH_SOURCE_PATH` or a current script
# directory in case if a relative inclusion path is not applicable to
# paths from the `BASH_SOURCE_PATH` variable.
#
# Additionally, the script can find a version of a bash shell executable and
# call the interpreter from the "/usr/local/bin" directory if it exists,
# otherwise would call from the "/bin" directory bypassing any user mount point
# redirection that may exist on the way (useful in cygwin/msys/mingw contexts).
#

if /bin/test "${BASH+set}" != set -o "${BASH_VERSINFO+set}" != "set" -o ${BASH_VERSINFO[0]:-0} -lt 3 >/dev/null 2>&1; then
  echo "bash_entry: error: script designed only for the Bash version 3.x or higher." >&2
  exit 253
fi

if [[ -n "$BASH" ]]; then

# WORKAROUND:
#   The `declare -g` has been introduced in the `bash-4.2-alpha`, so to make
#   a global variable in an older version we have to replace the
#   `declare -g` by a sequence of calls to `unset` and `eval`.
#
#   The `tkl_return_local` has used for both issues:
#   1. To return a local variable.
#   2. To replace the `declare -g`.
#
function tkl_return_local()
{
  unset $1 # must be local
  tkl_declare_global "$@"
}

function tkl_declare_global()
{
  eval "$1=\"\$2\"" # right argument does NOT evaluate
}

function tkl_declare_global_eval()
{
  eval "$1=\"$2\"" # right argument does evaluate
}

function tkl_export()
{
  eval "$1=\"\$2\"" # right argument does NOT evaluate
  export $1
}

function tkl_export_eval()
{
  eval "$1=\"$2\"" # right argument does evaluate
  export $1
}

function tkl_eval_if()
{
  eval "[[ $@ ]]" && return 0
  return 1
}

function tkl_eval_if_expr()
{
  eval "(( $@ ))" && return 0
  return 1
}

# replacement of the `true` command, as it can be an external process
function tkl_true()
{
  return 0
}

# replacement of the `false` command, as it can be an external process
function tkl_false()
{
  return 1
}

function tkl_set_return()
{
  return ${1:-0};
}

function tkl_push_var_to_stack_impl()
{
  # CAUTION:
  #   1. All variables here must be unique irrespective to the function scope,
  #      because `if [[ -n "${var_name+x}" ]]` still can be applied to a local variable!
  #   2. Must be used only exportable variables (not arrays) to pass the stack
  #      through the bash-to-bash process barrier.
  #

  if [[ -z "$1" ]]; then
    echo "tkl_push_var_to_stack_impl: stack entry must be not empty" >&2
    return 1
  fi
  if [[ -z "$2" ]]; then
    echo "tkl_push_var_to_stack_impl: variable name must be not empty: stack_entry=\`$1\`" >&2
    return 2
  fi

  #local _2BA2974B_stack_entry="$1"
  #local _2BA2974B_var_name="$2"
  #local _2BA2974B_var_value="$3"

  local _2BA2974B_vars_stack_size
  tkl_eval_if -n "\${tkl__vars_stack__$1__$2__size}" && {
    tkl_declare_global_eval _2BA2974B_vars_stack_size "\${tkl__vars_stack__$1__$2__size}"
    tkl_true
  } || _2BA2974B_vars_stack_size=0

  tkl_export_eval "tkl__vars_stack__$1__$2__${_2BA2974B_vars_stack_size}" "\${$2}"
  tkl_eval_if -n "\${$2+x}" && {
    tkl_export "tkl__vars_stack__$1__$2__${_2BA2974B_vars_stack_size}__defined" 1
    tkl_true
  } || {
    tkl_export "tkl__vars_stack__$1__$2__${_2BA2974B_vars_stack_size}__defined" 0
  }

  (( _2BA2974B_vars_stack_size++ ))
  tkl_export "tkl__vars_stack__$1__$2__size" "${_2BA2974B_vars_stack_size}"

  return 0
}

function tkl_pushset_var_to_stack()
{
  tkl_push_var_to_stack_impl "$@" && \
  tkl_declare_global "$2" "$3"
}

function tkl_pushunset_var_to_stack()
{
  tkl_push_var_to_stack_impl "$@" && \
  unset $2
}

function tkl_pop_var_from_stack()
{
  # INFO:
  #   1. All variables here must be unique irrespective to the function scope,
  #      because `unset ${var_name}` still can be applied to a local variable!
  #   2. Must be used only exportable variables (not arrays) to pass the stack
  #      through the bash-to-bash process barrier.
  #

  if [[ -z "$1" ]]; then
    echo "tkl_pop_var_from_stack: stack entry must be not empty" >&2
    return 1
  fi
  if [[ -z "$2" ]]; then
    echo "tkl_pop_var_from_stack: variable name must be not empty: stack_entry=\`$1\`" >&2
    return 2
  fi

  #local _2BA2974B_stack_entry="$1"
  #local _2BA2974B_var_name="$2"

  local _2BA2974B_vars_stack_size
  tkl_declare_global_eval _2BA2974B_vars_stack_size "\${tkl__vars_stack__$1__$2__size}"
  if [[ -z "${_2BA2974B_vars_stack_size}" ]] || (( ! _2BA2974B_vars_stack_size )); then
    echo "tkl_pop_var_from_stack: variables stack either undefined or empty" >&2
    return 3
  fi

  local _2BA2974B_vars_stack_next_size
  (( _2BA2974B_vars_stack_next_size=_2BA2974B_vars_stack_size-1 ))

  local _2BA2974B_is_var_defined
  tkl_declare_global_eval _2BA2974B_is_var_defined "\${tkl__vars_stack__$1__$2__${_2BA2974B_vars_stack_next_size}__defined}"
  if (( _2BA2974B_is_var_defined )); then
    tkl_export_eval "$2" "\${tkl__vars_stack__$1__$2__${_2BA2974B_vars_stack_next_size}}"
  else
    unset $2
  fi

  if [[ -n "${_2BA2974B_vars_stack_next_size}" ]] && (( _2BA2974B_vars_stack_next_size )); then
    tkl_export "tkl__vars_stack__$1__$2__size" "${_2BA2974B_vars_stack_next_size}"
  else
    unset tkl__vars_stack__$1__$2__size
  fi

  # unset previous
  unset tkl__vars_stack__$1__$2__${_2BA2974B_vars_stack_next_size}
  unset tkl__vars_stack__$1__$2__${_2BA2974B_vars_stack_next_size}__defined

  return 0
}

function tkl_get_var_stack_size()
{
  # drop return value
  RETURN_VALUE=""

  if [[ -z "$1" ]]; then
    echo "tkl_get_var_stack_size: stack entry must be not empty" >&2
    return 1
  fi
  if [[ -z "$2" ]]; then
    echo "tkl_get_var_stack_size: variable name must be not empty: stack_entry=\`$1\`" >&2
    return 2
  fi

  #local stack_entry="$1"
  #local var_name="$2"

  tkl_declare_global_eval RETURN_VALUE "\${tkl__vars_stack__$1__$2__size}"
  if [[ -z "$RETURN_VALUE" ]]; then
    RETURN_VALUE=0
  fi

  return 0
}

function tkl_is_abs_path()
{
  local file_path="$1"

  if [[ "${file_path:0:1}" == "/" || "${file_path:0:1}" == "\\" ]]; then
    RETURN_VALUE=1
    return 0
  elif (( ${#file_path} >= 2 )) && [[ "${file_path:1:0}" == ":" ]]; then
    RETURN_VALUE=1
    return 0
  fi

  RETURN_VALUE=0
  return 1
}

function tkl_get_source_file_path()
{
  # drop return value
  RETURN_VALUE=""

  if [[ -n "$BASH_LINENO" ]] && (( ${BASH_LINENO[${#BASH_LINENO[@]}-1]} > 0 )); then
    local ScriptFilePath="${BASH_SOURCE[${#BASH_LINENO[@]}-1]//\\//}"
  else
    local ScriptFilePath="${0//\\//}"
  fi

  tkl_get_abs_path_from_dir "$ScriptFilePath" && tkl_convert_backend_path_to_native "$RETURN_VALUE" -s
}

function tkl_make_source_file_components_from_file_path()
{
  tkl_export BASH_SOURCE_FILE "$1"
  tkl_export BASH_SOURCE_DIR "${1%[/]*}"
  tkl_export BASH_SOURCE_FILE_NAME "${1##*[/]}"
}

function tkl_make_source_file_components()
{
  tkl_get_source_file_path || return $?

  tkl_make_source_file_components_from_file_path "$RETURN_VALUE"
}

# Alternative inclusion command additionally to the `source` command.
function tkl_include()
{
  # CAUTION:
  #   1. All variables here must be unique irrespective to the function scope,
  #      because `source "..."` still can remove or change a local variable!

  if [[ -z "$BASH_SOURCE_DIR" ]]; then
    tkl_make_source_file_components
  fi

  local _84CB4B34_include_file_path
  for _84CB4B34_include_file_path in "$@"; do
    if tkl_is_abs_path "$_84CB4B34_include_file_path"; then
      if tkl_get_abs_path_from_dir "$_84CB4B34_include_file_path" && tkl_convert_backend_path_to_native "$RETURN_VALUE" -s; then
        tkl_include_local_impl
      fi
    else
      local _84CB4B34_included=0

      if [[ -n "$BASH_SOURCE_PATH" ]]; then
        local _84CB4B34_path_prefix
        case "$OSTYPE" in
          cygwin* | msys* | mingw*)
            local IFS=$';\t\r\n'
          ;;
          *)
            local IFS=$':\t\r\n'
          ;;
        esac
        for _84CB4B34_path_prefix in $BASH_SOURCE_PATH; do
          if [[ "${_84CB4B34_include_file_path:0:1}" == "/" || "${_84CB4B34_include_file_path:0:1}" == "\\" ]]; then
            if tkl_get_abs_path_from_dir "${_84CB4B34_path_prefix}${_84CB4B34_include_file_path}" && tkl_convert_backend_path_to_native "$RETURN_VALUE" -s; then
              if [[ -f "$RETURN_VALUE" ]]; then
                _84CB4B34_included=1
                tkl_include_local_impl
                break
              fi
            fi
          else
            if tkl_get_abs_path_from_dir "${_84CB4B34_path_prefix}/${_84CB4B34_include_file_path}" && tkl_convert_backend_path_to_native "$RETURN_VALUE" -s; then
              if [[ -f "$RETURN_VALUE" ]]; then
                _84CB4B34_included=1
                tkl_include_local_impl
                break
              fi
            fi
          fi
        done
      fi

      if (( ! _84CB4B34_included )); then
        if tkl_get_abs_path_from_dir "$BASH_SOURCE_DIR" "$_84CB4B34_include_file_path" && tkl_convert_backend_path_to_native "$RETURN_VALUE" -s; then
          tkl_include_local_impl
        fi
      fi
    fi
  done
}

# CAUTION:
#   The function MUST NOT have has any arguments, otherwise arguments WILL PASS inside the `source` statement!
#
function tkl_include_local_impl()
{
  # CAUTION:
  #   DO NOT USE `trap` command here and anythere else to pop the variables, because the `source` command would trigger it TOO!
  #

  #echo "tkl_include_local_impl: ${BASH_SOURCE_FILE} -> $1"

  local RETURN_VALUE="$RETURN_VALUE"

  tkl_pushset_var_to_stack global BASH_SOURCE_FILE "$RETURN_VALUE"
  tkl_pushset_var_to_stack global BASH_SOURCE_DIR "${RETURN_VALUE%[/]*}"
  tkl_pushset_var_to_stack global BASH_SOURCE_FILE_NAME "${RETURN_VALUE##*[/]}"

  #echo " -> BASH_SOURCE_FILE=${BASH_SOURCE_FILE}"
  #echo " -> BASH_SOURCE_DIR=${BASH_SOURCE_DIR}"
  #echo " -> BASH_SOURCE_FILE_NAME=${BASH_SOURCE_FILE_NAME}"

  source "${BASH_SOURCE_FILE}"

  # manually restore the stack, avoid usage of the `trap` command, because of side effect around the `source` command!
  tkl_pop_var_from_stack global BASH_SOURCE_FILE
  tkl_pop_var_from_stack global BASH_SOURCE_DIR
  tkl_pop_var_from_stack global BASH_SOURCE_FILE_NAME

  #echo " <- BASH_SOURCE_FILE=${BASH_SOURCE_FILE}"
  #echo " <- BASH_SOURCE_DIR=${BASH_SOURCE_DIR}"
  #echo " <- BASH_SOURCE_FILE_NAME=${BASH_SOURCE_FILE_NAME}"
}

function tkl_get_native_parent_dir()
{
  tkl_convert_backend_path_to_native "$1" s

  RETURN_VALUE="${RETURN_VALUE%[/]*}"
  [[ -z "$RETURN_VALUE" ]] && return 1

  case "$OSTYPE" in
    cygwin* | msys* | mingw*)
      if [[ "${RETURN_VALUE: -1:1}" == ":" ]]; then
        RETURN_VALUE="" # root directory does not have a parent directory
        return 1
      fi
    ;;
  esac

  return 0
}

### traplib.sh ###

function tkl_get_trap_cmd_line()
{
  tkl_get_trap_cmd_line_impl RETURN_VALUES "$@"
}

function tkl_get_trap_cmd_line_impl()
{
  local out_var="$1"
  shift

  # drop return values
  eval "$out_var=()"

  local trap_sig
  local stack_var
  local stack_arr
  local trap_cmdline
  local trap_prev_cmdline
  local i

  i=0
  for trap_sig in "$@"; do
    stack_var="_traplib_stack_${trap_sig}_cmdline"
    declare -a "stack_arr=(\"\${$stack_var[@]}\")"
    if (( ${#stack_arr[@]} )); then
      for trap_cmdline in "${stack_arr[@]}"; do
        declare -a "trap_prev_cmdline=(\"\${$out_var[i]}\")"
        if [[ -n "$trap_prev_cmdline" ]]; then
          eval "$out_var[i]=\"\$trap_cmdline; \$trap_prev_cmdline\"" # the last stored is the first executed
        else
          eval "$out_var[i]=\"\$trap_cmdline\""
        fi
      done
    else
      # use the signal current trap command line
      declare -a "trap_cmdline=(`trap -p "$trap_sig"`)"
      eval "$out_var[i]=\"\${trap_cmdline[2]}\""
    fi
    (( i++ ))
  done
}

function tkl_push_trap()
{
  # drop return values
  EXIT_CODES=()
  RETURN_VALUES=()

  local cmdline="$1"
  [[ -z "$cmdline" ]] && return 0 # nothing to push
  shift

  local trap_sig
  local stack_var
  local stack_arr
  local trap_cmdline_size
  local prev_cmdline

  for trap_sig in "$@"; do
    stack_var="_traplib_stack_${trap_sig}_cmdline"
    declare -a "stack_arr=(\"\${$stack_var[@]}\")"
    trap_cmdline_size=${#stack_arr[@]}
    if (( trap_cmdline_size )); then
      # append to the end is equal to push trap onto stack
      eval "$stack_var[trap_cmdline_size]=\"\$cmdline\""
    else
      # first stack element is always the trap current command line if not empty
      declare -a "prev_cmdline=(`trap -p $trap_sig`)"
      if (( ${#prev_cmdline[2]} )); then
        eval "$stack_var=(\"\${prev_cmdline[2]}\" \"\$cmdline\")"
      else
        eval "$stack_var=(\"\$cmdline\")"
      fi
    fi
    # update the signal trap command line
    tkl_get_trap_cmd_line "$trap_sig"
    trap "${RETURN_VALUES[0]}" "$trap_sig"
    EXIT_CODES[i++]=$?
  done
}

function tkl_pop_trap()
{
  # drop return values
  EXIT_CODES=()
  RETURN_VALUES=()

  local IFS

  local trap_sig
  local stack_var
  local stack_arr
  local trap_cmdline_size
  local trap_cmdline
  local i

  i=0
  for trap_sig in "$@"; do
    stack_var="tkl__traps_stack__${trap_sig}"
    declare -a "stack_arr=(\"\${$stack_var[@]}\")"
    trap_cmdline_size=${#stack_arr[@]}
    if (( trap_cmdline_size )); then
      (( trap_cmdline_size-- ))
      RETURN_VALUES[i]="${stack_arr[trap_cmdline_size]}"
      # unset the end
      unset $stack_var[trap_cmdline_size]
      (( !trap_cmdline_size )) && unset $stack_var

      # update the signal trap command line
      if (( trap_cmdline_size )); then
        tkl_get_trap_cmd_line_impl trap_cmdline "$trap_sig"
        trap "${trap_cmdline[0]}" "$trap_sig"
      else
        trap "" "$trap_sig" # just clear the trap
      fi
      EXIT_CODES[i]=$?
    else
      # nothing to pop
      RETURN_VALUES[i]=""
    fi
    (( i++ ))
  done
}

function tkl_pop_exec_trap()
{
  # drop exit codes
  EXIT_CODES=()

  tkl_pop_trap "$@"

  local i=0
  local cmdline

  for cmdline in "${RETURN_VALUES[@]}"; do
    # execute as function and store exit code
    eval "function _traplib_immediate_handler() { $cmdline; }"
    _traplib_immediate_handler
    EXIT_CODES[i++]=$?
    unset _traplib_immediate_handler
  done
}

function tkl_get_abs_path_from_dir()
{
  # drop return value
  RETURN_VALUE=""

  local DirPath="$1"
  local RelativePath="$2"

  # drop line returns
  DirPath="${DirPath//[$'\r\n']}" 
  RelativePath="${RelativePath//[$'\r\n']}" 

  # WORKAROUND:
  #   Because some versions of readlink can not handle windows native absolute
  #   paths correctly, then always try to convert directory path to a backend
  #   path before the readlink in case if the path has specific native path
  #   characters.
  if [[ "${DirPath:1:1}" == ":" ]]; then
    tkl_convert_native_path_to_backend "$DirPath"
    DirPath="$RETURN_VALUE"
  fi

  if [[ -n "$DirPath" ]]; then
    if [[ -x "/bin/readlink" ]]; then
      if [[ "${RelativePath:0:1}" != '/' ]]; then
        RETURN_VALUE=$(/bin/readlink -m "$DirPath${RelativePath:+/}$RelativePath")
      else
        RETURN_VALUE=$(/bin/readlink -m "$RelativePath")
      fi
    else
      return 1
    fi
  else
    return 2
  fi
}

function tkl_convert_backend_path_to_native()
{
  # cygwin/msys2 uses cygpath command to convert paths
  # msys/mingw uses old style conversion through the "cmd.exe ^/C" call

  # drop return value
  RETURN_VALUE="$1"

  local LastError=0
  local PathToConvert="$1"
  local Flags="$2"

  local ConvertedPath=""

  if [[ "${Flags/i/}" != "$Flags" ]]; then
    # w/ user mount points bypassing
    tkl_exctract_path_ignoring_user_mount_points -w "$PathToConvert"
    LastError=$?
  fi

  if [[ "${Flags/s/}" != "$Flags" ]]; then
    # convert backslashes to slashes
    RETURN_VALUE="${RETURN_VALUE//\\//}"
  fi

  if [[ "${Flags/i/}" != "$Flags" ]]; then
    return $LastError
  fi

  [[ -n "$PathToConvert" ]] || return 1

  tkl_get_abs_path_from_dir "$PathToConvert" || return 2

  case "$OSTYPE" in
    msys* | mingw*)
      while true; do
        # in msys2 and higher we must use /bin/cygpath.exe to convert the path
        if [[ "$OSTYPE" == "msys" && -f "/bin/cygpath.exe" ]]; then
          ConvertedPath="`/bin/cygpath.exe -w "$RETURN_VALUE"`"
          break
        fi
        local ComSpecInternal="${COMSPEC//\\//}" # workaround for a "command not found" in the msys shell
        # msys replaces mount point path properly if it ends by '/' character
        RETURN_VALUE="${RETURN_VALUE%/}/"
        tkl_escape_string "$RETURN_VALUE" '' 2
        # msys automatically converts argument to the native path if it begins from '/' character
        ConvertedPath="`"$ComSpecInternal" '^/C' \(echo $RETURN_VALUE\)`"
        break
      done
    ;;

    cygwin*)
      ConvertedPath="`/bin/cygpath.exe -w "$RETURN_VALUE"`"
    ;;

    *)
      if [[ "${Flags/s/}" != "$Flags" ]]; then
        # convert backslashes to slashes
        RETURN_VALUE="${RETURN_VALUE//\\//}"
      fi

      return 0
    ;;
  esac

  # remove last slash
  ConvertedPath="${ConvertedPath%[/\\]}"

  if [[ "${Flags/s/}" != "$Flags" ]]; then
    # convert backslashes to slashes
    RETURN_VALUE="${ConvertedPath//\\//}"
  else
    # convert all slashes to backward slashes
    RETURN_VALUE="${ConvertedPath//\//\\}"
  fi

  return 0
}

function tkl_find_char()
{
  # drop return value
  RETURN_VALUE=""

  # (Required) String which would be searched.
  local String="$1"
  # (Required) Chars for search.
  local Chars="$2"

  if [[ -z "$String" ]]; then
    RETURN_VALUE="-1"
    return 1
  fi
  if [[ -z "$Chars" ]]; then
    RETURN_VALUE="-1"
    return 2
  fi

  local StringLen="${#String}"
  local CharsLen="${#Chars}"
  local i
  local j
  for (( i=0; i < StringLen; i++ )); do
    for (( j=0; j < CharsLen; j++ )); do
      if [[ "${String:$i:1}" == "${Chars:$j:1}" ]]; then
        RETURN_VALUE="$i"
        return 0
        break
      fi
    done
  done

  RETURN_VALUE="-1"

  return 3
}

function tkl_escape_string()
{
  # drop return value
  RETURN_VALUE=""

  # (Required) String which would be escaped.
  local String="$1"
  # (Optional) Set of characters in string which are gonna be escaped.
  local EscapeChars="$2"
  # (Optional) Type of escaping:
  #   0 - String will be quoted by the " character, so escape any character from
  #       "EscapeChars" by the \ character.
  #   1 - String will be quoted by the ' character, so the ' character should be
  #       escaped by the \' sequance. The "EscapeChars" variable doesn't used in this case.
  #   2 - String will be used in the cmd.exe shell, so quote any character from
  #       the "EscapeChars" variable by the ^ character.
  local EscapeType="${3:-0}"

  if [[ -z "$String" ]]; then
    RETURN_VALUE="$String"
    return 1
  fi

  if [[ -z "$EscapeChars" ]]; then
    case $EscapeType in
      0) EscapeChars='$!&|\`"' ;;
      2) EscapeChars='^?*&|<>()"' ;;
    esac
  fi

  local EscapedString=""
  local StringCharEscapeOffset=-1
  local i
  for (( i=0; i<${#String}; i++ )); do
    local StringChar="${String:$i:1}"
    case $EscapeType in
      0)
        tkl_find_char "$EscapeChars" "$StringChar"
        StringCharEscapeOffset="$RETURN_VALUE"
        if (( StringCharEscapeOffset < 0 )); then
          EscapedString="$EscapedString$StringChar"
        else
          EscapedString="$EscapedString\\$StringChar"
        fi
      ;;
      1)
        if [[ "$StringChar" != "'" ]]; then
          EscapedString="$EscapedString$StringChar"
        else
          EscapedString="$EscapedString'\\''"
        fi
      ;;
      *)
        tkl_find_char "$EscapeChars" "$StringChar"
        StringCharEscapeOffset="$RETURN_VALUE"
        if (( StringCharEscapeOffset >= 0 )); then
          EscapedString="$EscapedString^"
        fi
        EscapedString="$EscapedString$StringChar"
      ;;
    esac
  done

  [[ -n "$EscapedString" ]] || return 2

  RETURN_VALUE="$EscapedString"

  return 0
}

function tkl_convert_native_path_to_backend()
{
  # drop return value
  RETURN_VALUE="$1"

  # Convert all back slashes to slashes.
  local PathToConvert="${1//\\//}"

  [[ -n "$PathToConvert" ]] || return 1

  # workaround for the bash 3.1.0 bug for the expression "${arg:X:Y}",
  # where "Y == 0" or "Y + X >= ${#arg}"
  local PathToConvertLen=${#PathToConvert}
  local PathPrefixes=('' '')
  local PathSuffix=""
  if (( PathToConvertLen > 0 )); then
    PathPrefixes[0]="${PathToConvert:0:1}"
  fi
  if (( PathToConvertLen > 1 )); then
    PathPrefixes[1]="${PathToConvert:1:1}"
  fi
  if (( PathToConvertLen >= 3 )); then
    PathSuffix="${PathToConvert:2}"
    PathSuffix="${PathSuffix%/}"
  fi

  # Convert path drive prefix too.
  if [[ "${PathPrefixes[0]}" != '/' && "${PathPrefixes[0]}" != '.' && "${PathPrefixes[1]}" == ':' ]]; then
    case "$OSTYPE" in
      cygwin*) PathToConvert="/cygdrive/${PathPrefixes[0]}$PathSuffix" ;;
      *)
        PathToConvert="/${PathPrefixes[0]}$PathSuffix"
        # add slash to the end of path in case of drive only path
        (( ! ${#PathSuffix} )) && PathToConvert="$PathToConvert/"
      ;;
    esac
  fi

  RETURN_VALUE="$PathToConvert"

  return 0
}

function tkl_exctract_path_ignoring_user_mount_points()
{
  # Splits the path into 2 paths by exracting builtin paths from the beginning of
  # the path in this order:
  # "/usr/bin" => "/usr/lib" => "/usr" => "/lib" => "/<drive>/" => "/"
  # That is because, the Cygwin backend has the redirection of
  # "/usr/bin" and "/usr/lib" into "/bin" and "/lib" paths respectively, but
  # doesn't has the redirection of the "/usr" itself, when the Msys backend has
  # the redirection of the "/usr" path to the "/" but does not has for the
  # "/usr/bin" path.

  # Examples:
  # 1. path=/usr/bin       => prefix=/usr/bin/    suffix=
  # 2. path=/usr/lib       => prefix=/usr/lib/    suffix=
  # 3. path=/usr           => prefix=/usr/        suffix=
  # 4. path=/lib           => prefix=/lib/        suffix=
  # 5. path=/usr/local/bin => prefix=/usr/        suffix=local/bin
  # 6. path=/tmp           => prefix=/            suffix=tmp
  # Specific to Msys behaviour:
  # 7. path=/c/            => prefix=/c/          suffix=
  # 8. path=/c             => prefix=/            suffix=c
  # Specific to Cygwin behaviour:
  # 9. path=/cygdrive/c    => prefix=/cygdrive/c  suffix=

  local Flags="$1"
  if [[ "${Flags:0:1}" == '-' ]]; then
    shift
  else
    Flags=''
  fi
  local PathToConvert="$1"

  # drop return value
  RETURN_VALUE=""

  (( ${#PathToConvert} )) || return 1

  local DoConvertToBackendTypePath=1
  if [[ "${Flags//w/}" != "$Flags" ]]; then
    DoConvertToBackendTypePath=0 # convert to native path
  elif [[ "${Flags//b/}" != "$Flags" ]]; then # explicit flag
    DoConvertToBackendTypePath=1 # convert to backend path
  fi

  # enable nocase match
  local oldShopt=""
  function LocalReturn()
  {
    if [[ -n "$oldShopt" ]]; then
      # Restore state
      eval $oldShopt
    fi
    unset -f "${FUNCNAME[0]}" # drop function after execution
  }

  trap "LocalReturn; trap - RETURN" RETURN || return 253

  oldShopt="$(shopt -p nocasematch)" # Read state before change
  if [[ "$oldShopt" != "shopt -s nocasematch" ]]; then
    shopt -s nocasematch
  else
    oldShopt=''
  fi

  # The case patterns w/o * ending character.
  # If / character at the end then it is required.
  local PathPrefixes=(/usr/bin /usr/lib /usr /lib '/[a-zA-Z]/' '/cygdrive/[a-zA-Z]' /)

  local PathPrefix
  local PathSuffix

  local IsFound=0

  for PathPrefix in "${PathPrefixes[@]}"; do
    PathSuffix="${PathToConvert#$PathPrefix}"
    if [[ "$PathSuffix" != "$PathToConvert" ]] &&
       [[ -z "$PathSuffix" || "${PathSuffix:0:1}" == '/' || "${PathPrefix%/}" != "$PathPrefix" ]]; then
      IsFound=1
      PathPrefix="${PathToConvert%$PathSuffix}"
      break
    fi
  done

  if (( ! IsFound )); then
    PathPrefix="$PWD" # current path as base if builtin is not found
    PathSuffix="$PathToConvert"
  fi

  PathPrefix="${PathPrefix%/}/" # forward slash at the end
  PathSuffix="${PathSuffix#/}"  # no forward slash at the begin
  PathSuffix="${PathSuffix%/}"  # no forward slash at the end

  local ConvertedPath

  # bypassing mounting points
  case "$OSTYPE" in
    msys* | mingw*)
      while true; do
        # in msys2 and higher we must use /bin/cygpath.exe to convert the path
        if [[ "$OSTYPE" == "msys" && -f "/bin/cygpath.exe" ]]; then
          ConvertedPath="`/bin/cygpath.exe -w "$RETURN_VALUE"`"
          break
        fi
        local ComSpecInternal="${COMSPEC//\\//}" # workaround for a "command not found" in the msys shell
        # msys replaces mount point path properly if it ends by '/' character
        RETURN_VALUE="${PathPrefix%/}/"
        tkl_escape_string "$RETURN_VALUE" '' 2
        # msys automatically converts argument to the native path if it begins from '/' character
        ConvertedPath="$("$ComSpecInternal" '^/C' \(echo $RETURN_VALUE\))"
        break
      done
      ;;

    cygwin*)
      ConvertedPath="`/bin/cygpath.exe -w "$PathPrefix"`"
      ;;

    *)
      RETURN_VALUE="${PathPrefix%/}${PathSuffix:+/}$PathSuffix"
      return 0
      ;;
  esac

  # remove last slash
  ConvertedPath="${ConvertedPath%[/\\]}"
  # convert to declared path type with replacemant of all backward slashes
  if (( DoConvertToBackendTypePath )); then
    tkl_convert_native_path_to_backend "${ConvertedPath//\//\\}" || return 3
    RETURN_VALUE="$RETURN_VALUE${PathSuffix:+/}$PathSuffix"
  else
    RETURN_VALUE="${ConvertedPath//\\//}${PathSuffix:+/}$PathSuffix"
  fi

  return 0
}

function tkl_bash_entry()
{
  local BashEntryPath="$1"
  [[ -n "$BashEntryPath" ]] || return 1

  trap ':' RETURN # set to empty command to avoid reset from child function calls

  tkl_exctract_path_ignoring_user_mount_points -b "$BashEntryPath" || return 2
  export BASH_ENTRY_FILE="$RETURN_VALUE"

  return 0
}

if [[ -z "$BASH_LINENO" || ${BASH_LINENO[0]} -eq 0 ]]; then
  # Script was not included, then execute it. 

  if [[ -z "$BASH_ENTRY_FILE" || ! -f "$BASH_ENTRY_FILE" ]]; then
    tkl_bash_entry "/usr/local/bin/bash"
  fi

  if [[ -z "$BASH_ENTRY_FILE" || ! -f "$BASH_ENTRY_FILE" ]]; then
    tkl_bash_entry "/bin/bash"
  fi

  if [[ -n "$BASH_ENTRY_FILE" ]]; then
    # do cache path to shell to avoid redundant execution in a child shells
    "$BASH_ENTRY_FILE" "$@"
  else
    /bin/bash "$@"
  fi

  # always exit with current exit code
  exit $?
fi

fi
